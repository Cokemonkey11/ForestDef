package Entity
import LinkedListModule
import Terrain
import PhysicsConstants
import Debug
import Fx
import Angle
import initlater Buff
import initlater Tower
import public ArrayList
import public DmgMod
import initlater PhysicsProjectile
import MapBounds
/** Base Entity Class  */
public abstract class Entity
	use LinkedListModule
	
	/** 3d vector position */
	vec3 pos
	/** 3d vector velocity */
	vec3 vel
	
	/** radius */
	real radius = 0.
	/** speed factor (multiplies to added velocity) */
	real speedFactor = 1.
	
	/** owning player */
	player owner
	
	/** flag for being static */
	boolean isStatic 	= false
	/** sleeping or active? */
	boolean active 		= true
	boolean flying 		= false

	construct( vec3 pos, player owner )
		this.pos = pos
		this.vel = vec3(0,0,0)
		this.owner = owner

	construct( vec3 pos, real radius, player owner )
		this.pos = pos
		this.vel = vec3(0,0,0)
		this.owner = owner
		this.radius = radius
		
	construct( vec3 pos, vec3 vel, player owner )
		this.pos = pos
		this.vel = vel
		this.owner = owner
		
	construct( vec3 pos, vec3 vel, real radius, player owner )
		this.pos = pos
		this.vel = vel
		this.owner = owner
		this.radius = radius
		
	function getPos() returns vec3
		return pos
		
	function setPos( vec3 pos )
		this.pos = pos
		
	function addPos( vec3 pos )
		this.pos += pos
		
	function getVel() returns vec3
		return vel
		
	function setVel( vec3 vel )
		this.vel = vel
		active = true
	
	function addVel( vec3 vel )
		this.vel += vel
		
	function setTarget( vec3 tpos, real speed )
		var t = distanceBetweenCoords(pos.x, pos.y, tpos.x, tpos.y) / speed
		let tangle = angleBetweenCoords(pos.x, pos.y, tpos.x, tpos.y)
		let e = getTerrainZ(tpos.x,tpos.y)
		
		if t < 1.
			t = 1./speed
		
		let startZVelocity = ((-gravity.z * t) / 2 - pos.z/t + e/t)
		this.setVel( vec3( Cos(tangle.radians()) * speed, Sin(tangle.radians()) * speed, startZVelocity) )
		
	/** This function is called every ANIMATION_PERIOD tick if the Entity is active */
	abstract function update()
	
abstract public class UnitEntity extends Entity
	static trigger dmgTrig = CreateTrigger()
	static trigger deathTrig = CreateTrigger()
	unit actor
	
	ArrayList<Buff> currentBuffs = new ArrayList<Buff>()
	
	construct( vec3 pos, unit actor )
		super(pos, actor.getOwner())
		this.actor = actor
		actor..setUserData(this castTo int)..addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
		dmgTrig.registerUnitEvent(actor, EVENT_UNIT_DAMAGED)
		deathTrig.registerUnitEvent(actor, EVENT_UNIT_DEATH)
		unitEntityCount++
		
	construct( vec3 pos, real radius, unit actor )
		super(pos, radius, actor.getOwner())
		this.actor = actor
		actor..setUserData(this castTo int)..addAbility(HEIGHT_ENABLER).removeAbility(HEIGHT_ENABLER)
		dmgTrig.registerUnitEvent(actor, EVENT_UNIT_DAMAGED)
		unitEntityCount++
		
	override function update()
		updatePos()
		
	function updatePos()
		pos = vec3(actor.getX(), actor.getY(), 0.)
		
	function setNewActor(unit u)
		actor.remove()
		actor = u
		actor.setUserData(this castTo int)
		
	override function setPos(vec3 tpos)
		pos = tpos
		if(pos.inPlayable())
			actor.setPos(tpos.x,tpos.y)
			actor.setFlyHeight(tpos.z - getTerrainZ(tpos.x, tpos.y), 0)
		else 
			destroy this
		
	function setXY(vec3 tpos)
		pos = tpos
		actor.setXY(tpos.x,tpos.y)
		
	static function onDamage()
		debugPrint("onDamage " + getDamage().toString() , 2)
		let v = GetTriggerUnit()
		let a = GetEventDamageSource()
		debugPrint("onDamage a: " + a.getName() , 2)
		debugPrint("onDamage v: " + v.getName() , 2)
		if a.getHP() < 0.405 or v.getHP() < 0.405
			return
		debugPrint("onDamage both alive" , 2)
		let victimData = v.getUserData() castTo UnitEntity
		let attackerData = a.getUserData() castTo UnitEntity
		if IsPlayerAlly(victimData.owner, attackerData.owner) or victimData.owner == attackerData.owner
			modifyDamage(0)
			for bff in attackerData.currentBuffs
					bff.attackModifier()
					
			for i = 0 to 15
				var p =new PhysicsProjectile(victimData.getPos(), 32, attackerData.owner, angle(0), "Abilities\\Weapons\\VoidWalkerMissile\\VoidWalkerMissile.mdl", null )
				p.setVel(vec3(GetRandomReal(-1,1),GetRandomReal(-1,1),GetRandomReal(10,20)))
				p.setTimed(60)
				p.restitution = 0.98
				p.speedFactor = GetRandomReal(0.3, 1.2)
			
			debugPrint("onDamage no dmg " + getDamage().toString() , 2)
		else
			debugPrint("onDamage both alive else" , 2)
			if victimData != null
				debugPrint("vcitim != null" , 2)
				debugPrint("onDamage userData + " + GetAttacker().getName() , 2)
				debugPrint("def mod " + victimData.currentBuffs.getSize().toString() , 2)
				for bff in victimData.currentBuffs
					bff.defenseModifier()
					debugPrint("def mod" , 2)
					
				debugPrint("onDamage applied victim buffs attackerdata: " + (attackerData castTo int).toString()  , 2)
			
			debugPrint("attacker ? null" , 2)
			if attackerData != null
				debugPrint("attacker != null" , 2)
				debugPrint("onDamage attack != null" , 0)
				for bff in attackerData.currentBuffs
					bff.attackModifier()
				if attackerData instanceof Tower
					debugPrint("onDamage attack == tower" , 0)
					let td = attackerData castTo Tower
					victimData.updatePos()
					td.onAttack(victimData)
					debugPrint("onDamage called onAttack" , 0)
			else
				debugPrint("attacker == null" , 2)
				
	function onDeath(unit killer)
		destroy this
			
	static function onEventDeath()
		let data = GetTriggerUnit().getUserData() castTo UnitEntity
		data.onDeath(GetKillingUnit())
		

		
init
	UnitEntity.dmgTrig.addAction(function UnitEntity.onDamage)		
	UnitEntity.deathTrig.addAction(function UnitEntity.onEventDeath)

abstract public class FxEntity extends Entity
	protected Fx fx
	
	construct( vec3 pos, real radius, player owner, angle xyAngle, string sfxpath )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle, sfxpath)
		fx.setOwner(owner, true)
		
	construct( vec3 pos, real radius, player owner, angle xyAngle )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
	
	construct( vec3 pos, player owner, angle xyAngle )
		super(pos, 0., owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
		
	override function update()
		pos += (vel*speedFactor)
		setPos()
		
	function setFx(string sfxpath)
		fx.setFx(sfxpath)
		
	function setPos()
		if(pos.inPlayable())
			fx.setXYZ(pos)
		else 
			destroy this
		
	function getDummy() returns unit
		return fx.getDummy()
		
	override function setPos(vec3 tpos)
		pos = tpos
		fx.setPos(tpos.x,tpos.y)
		
	ondestroy
		debugPrint("fx destroyed", 1)
		destroy fx





	