package HealbackTower
import Assets
import Tower
import Projectile
import PlayerData
import PresetBuffs
import ObjectIdGenerator
import AbilityObjEditing
import BuffObjEditing
import ObjectIds
import TextTagEntity

public constant HEALBACK_TOWER_ID = 'h02A'
constant HEALBACK_MULTIPLIERS = [1.75, 1.5, 2.0, 1.75]
constant HEALBACK_MISSILE_COUNTS = [1, 2, 2, 3]
constant HEALBACK_RANGES = [850., 875., 925., 975.]

tuple HealbackTarget(UnitEntity e, real distance)

public class HealbackTower extends Tower
	var level = 1

	construct(Tower t)
		super(t)

	static function getMultiplier(int level) returns real
		return HEALBACK_MULTIPLIERS[level - 1]
	
	static function getMissileCount(int level) returns int
		return HEALBACK_MISSILE_COUNTS[level - 1]

	static function getRange(int level) returns real
		return HEALBACK_RANGES[level - 1]
	
	static constant nearEntities = new LinkedList<EntityWithDist>()
	static var statSource = ZERO2
	static Comparator<EntityWithDist> comparator = (EntityWithDist e1, EntityWithDist e2) -> e1.distSq - e2.distSq
	static function getNearestBuilding(vec2 source, int count, real range) returns LinkedList<UnitEntity>
		statSource = source
		GroupEnumUnitsInRange(ENUM_GROUP, source.x, source.y, range, Filter(() -> begin
			var u = GetFilterUnit()
			var viable = true
			// filter structureds
			if not IsUnitType(u, UNIT_TYPE_STRUCTURE) or not u.isAlive()
				viable = false
			
			// filter player owner
			if viable and pDatas[u.getOwner().getId()] == null
				viable = false
			
			// filter if wall or tower building
			if viable
				var e = u.getEntity()
				if not (e instanceof Wall or e instanceof Tower)
					viable = false
				// filter out full hp
				if u.getHP() == u.getMaxHP()
					viable = false
			if viable
				nearEntities.add(new EntityWithDist(u.getEntity() castTo UnitEntity, statSource.distanceToSq(u.getPos())))
		end))

		nearEntities.sortWith(comparator)
		
		var targets = new LinkedList<UnitEntity>()
		nearEntities.forEach((EntityWithDist e) -> begin
			if targets.size() < count
				targets.add(e.ue) 
			destroy e
		end)
		
		nearEntities.clear()
		return targets

	override function onUpgrade()
		level++

	function launchHealback(UnitEntity attacked, real damage)
		var creepPos = attacked.actor.getPos3Real()

		var targets = HealbackTower.getNearestBuilding(creepPos.toVec2(), getMissileCount(level), getRange(level))
		for target in targets
			new HealbackMissile(creepPos.add(0, 0, 48), owner, damage, target)

		destroy targets

	override function onAttack(UnitEntity target)
		var damage = getDamage()
		if damage > 0
			// new HealbackBuff(target, damage)
			launchHealback(target, damage * getMultiplier(level))

class EntityWithDist
	UnitEntity ue
	int distSq
	construct(UnitEntity ue, real dist)
		this.ue = ue
		this.distSq = dist.toInt()

constant HEALBACK_RADIUS = 32.
constant HEALBACK_EFFECT = Abilities.vampiricAuraTarget
constant HEALBACK_MISSILE_EFFECT = Abilities.faerieDragonMissile

public class HealbackMissile extends Projectile
	real heal
	UnitEntity target

	construct(vec3 pos, player owner, real heal, UnitEntity target)
		super(pos, HEALBACK_RADIUS, owner, pos.angleTo2d(target.getPos().add(0, 0, 30.)), HEALBACK_MISSILE_EFFECT)
		this.heal = heal
		this.target = target
		this.setTarget(target.actor.getPos3Real().add(0, 0, 32), 18.)
		fx.setColor(colorA(215, 255, 215, 168))

	override function update()
		super.update()
		vel += gravity
		if (pos.distanceTo2d(target.pos) < HEALBACK_RADIUS)
			onReachTarget()
			terminate()
 
	function onReachTarget()
		if (this.target != null and this.target.actor.isAlive())
			flashEffect(HEALBACK_EFFECT, target.pos.add(0, 0, 50))
			this.target.actor.addHP(this.heal)
			new TextTagEntity(pos, vec3(GetRandomReal(-1, 1),0, GetRandomReal(6,8)), this.heal.toInt().toString() , 8, 1., colorA(223, 255, 52, 255))


/** Creates an ability based on Tornado aura that allows to display a buff without side effects */
public function createBuffObjectWithAttachmentPoint(string name, string tooltip, string iconpath, string effectPath, string attachmentPoint) returns buffTuple
	let abilId = ABIL_ID_GEN.next()
	let buffId = BUFF_ID_GEN.next()

	if compiletime
		new BuffDefinition(buffId, 'Basl')
			..setName(1, name)
			..setTooltipNormal(1, name)
			..setTooltipNormalExtended(1, tooltip)
			..setIcon(iconpath)

		new AbilityDefinitionAuraSlow(abilId)
			..setName("Aura Dummy: " + name)
			..setMovementSpeedFactor(1, 0)
			..setBuffs(1, int2fourchar(buffId))
			..presetIcon(iconpath)
			..setArtTarget("")
			..setTargetsAllowed(1, "self")
			..setArtTarget(effectPath)
			..setTargetAttachmentPoint(attachmentPoint)
		
	return buffTuple(abilId, buffId)
